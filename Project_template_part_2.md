Это шаблон для решения **второй части** проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

Все задания в этой части проектной работы — дополнительные. Их можно сделать по желанию. Чтобы ревьюер быстрее проверил ваше решение, укажите, какие задания вы сделали. Для этого оставьте нужный эмодзи около заголовка задания:

✅ — вы выполнили это задание.

❌ — вы пропустили задание.

# Разработка MVP

# ✅ ❌ Задание 1. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.
REST API: Подходит для синхронных операций, где требуется запрос-ответ (например, создание, чтение, обновление ресурсов). Его простота и совместимость делают его идеальным для управления устройствами через пользовательские интерфейсы или внешние интеграции. REST легко тестируется и поддерживает кэширование для повышения производительности.

AsyncAPI (Kafka): Предназначен для асинхронной передачи данных, идеально подходит для обработки событий в реальном времени (например, статусы устройств или команды). Kafka обеспечивает высокую производительность и надежность при работе с большим объемом сообщений. Он удобен для построения распределенных систем с высокой нагрузкой.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# ✅ ❌ Задание 2. Новые микросервисы и интеграция с монолитом

### 1. Язык программирования

Опишите, какой язык вы выбрали для реализации микросервисов и почему.
Выбранный язык Java. Причины следующие:
- Универсальность и экосистема: Java предлагает мощные инструменты для разработки сложных приложений, а также множество библиотек и фреймворков, таких как Spring Boot, которые упрощают создание REST и Kafka-сервисов.
- Портируемость: Код на Java можно запускать на любой платформе благодаря JVM, что делает его подходящим для распределенных систем.
- Производительность и масштабируемость: Java предоставляет стабильную и высокопроизводительную среду, идеально подходящую для создания надежных и масштабируемых микросервисов.

### 2. Создание проекта

Укажите здесь ссылки на проекты, которые вы создали для микросервисов:

- Микросервис «Управление телеметрией» [management-telemetry](microservices%2Fmanagement-telemetry) **[swagger.yaml](microservices%2Fmanagement-telemetry%2Fswagger.yaml) [asyncapi.yaml](microservices%2Fmanagement-telemetry%2Fasyncapi.yaml)**  
- Микросервис «Управление устройствами» [management-device](microservices%2Fmanagement-device) **[swagger.yaml](microservices%2Fmanagement-device%2Fswagger.yaml)  [asyncapi.yaml](microservices%2Fmanagement-device%2Fasyncapi.yaml)**

### 4. Интеграция с монолитом

Укажите, какой способ взаимодействия микросервисов с монолитом вы выбрали. Поясните, почему остановились именно на нём.

### **5. Развёртывание в Minikube, либо Docker Compose**

Опишите полную инструкцию для развёртывания с нуля вашего решения, а так же тестовые запросы — Swagger.

- Перейдите в директорию с Helm-чартом:
```shell
cd ./microservices-chart
```
- Установите PostgreSQL, Kafka и Zookeeper
```shell
helm install postgresql ./templates/deployment-device-db.yaml
helm install zookeeper ./templates/deployment-zookeeper.yaml
helm install kafka ./templates/deployment-kafka.yaml
```
- Разверните микросервисы:
 ```shell
 helm install management-device ./templates/service-management-device.yaml
helm install management-telemetry ./templates/service-management-telemetry.yaml
```
### Проверка состояния
```shell
kubectl get pods
kubectl get svc
```
## **Дополнительная часть**

В ходе работы над заданием вы можете по желанию выполнить ряд условий. Оставьте рядом с описанием условий смайлик, который соответствует статусу решения, и своё пояснение:

- ❌ Реализован паттерн Saga для управления распределенными транзакциями между микросервисами.
- ❌ Разделены операции чтения и записи данных в микросервисах с помощью паттерна CQRS.
- ✅ Применены дополнительные принципы 12-факторных приложений.
- ✅ Использован Kafka кластер для обеспечения отказоустойчивости и масштабируемости.

# ✅ ❌ Задание 3. Подготовка 3rd party сервисов для связи микросервисов

1. ✅ ❌ **Развёрнут и настроен кластер Kafka.**
Этот пункт задания выполнять необязательно. Это зависит от того, как вы реализовали своё решение. Оставьте рядом с пунктом тот смайлик, который отражает ваш выбор. Если используете кластер Kafka, добавьте сюда ссылку.
2. **Развёрнут и настроен API Gateway**
Поясните, какие технологии для API Gateway вы используете. Оставьте ссылку.
3. **Тестирование**
Поясните, какие команды нужно использовать для тестирования.

# Автоматизация поставки

# ✅ ❌ Задание 1. Контейнеризация микросервисов

1. **Созданы Helm-чарты** 
2. **Docker-образы собраны и загружены в хранилище артефактов**
Добавьте сюда ссылку на GitHub Container Registry.
3. **Запуск сервисов**
Напишите, какие команды нужно использовать для запуска сервисов с нуля.
4. **Тестирование работы сервисов**
Напишите, какие команды нужно использовать для тестирования.

# ✅ ❌ Задание 2. Настройка CI/CD-пайплайнов **c помощью GitHub Actions**

1. **Созданы CI/CD-пайплайны для каждого микросервиса**
    - Опишите шаги пайплайна GitHub Actions в ci.yaml и добавьте сюда ссылку на этот файл.
    - Опишите шаги, которые нужно пройти для сборки, тестирования, загрузки образов в хранилище артефактов и обновления Helm релиза в Minikube.
2. **Настроены триггеры для запуска пайплайнов**

    Пайплайны настроены на запуск при каждом пуше кода в репозиторий.

3. **Проверена работа пайплайнов**

    Пайплайн автоматически запускается и успешно выполняет все этапы: сборка, тестирование, развертывание. Добавьте сюда ссылку, по которой можно посмотреть выполнение пайплайнов.
