Это шаблон для решения **второй части** проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

Все задания в этой части проектной работы — дополнительные. Их можно сделать по желанию. Чтобы ревьюер быстрее проверил ваше решение, укажите, какие задания вы сделали. Для этого оставьте нужный эмодзи около заголовка задания:

✅ — вы выполнили это задание.

❌ — вы пропустили задание.

# Разработка MVP

# ✅  Задание 1. Создание и документирование API

### 1. Тип API

Укажите, какой тип API вы будете использовать для взаимодействия микросервисов. Объясните своё решение.
REST API: Подходит для синхронных операций, где требуется запрос-ответ (например, создание, чтение, обновление ресурсов). Его простота и совместимость делают его идеальным для управления устройствами через пользовательские интерфейсы или внешние интеграции. REST легко тестируется и поддерживает кэширование для повышения производительности.

AsyncAPI (Kafka): Предназначен для асинхронной передачи данных, идеально подходит для обработки событий в реальном времени (например, статусы устройств или команды). Kafka обеспечивает высокую производительность и надежность при работе с большим объемом сообщений. Он удобен для построения распределенных систем с высокой нагрузкой.

### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# ✅  Задание 2. Новые микросервисы и интеграция с монолитом

### 1. Язык программирования

Опишите, какой язык вы выбрали для реализации микросервисов и почему.
Выбранный язык Java. Причины следующие:
- Универсальность и экосистема: Java предлагает мощные инструменты для разработки сложных приложений, а также множество библиотек и фреймворков, таких как Spring Boot, которые упрощают создание REST и Kafka-сервисов.
- Портируемость: Код на Java можно запускать на любой платформе благодаря JVM, что делает его подходящим для распределенных систем.
- Производительность и масштабируемость: Java предоставляет стабильную и высокопроизводительную среду, идеально подходящую для создания надежных и масштабируемых микросервисов.

### 2. Создание проекта

Укажите здесь ссылки на проекты, которые вы создали для микросервисов:

- Микросервис «Управление телеметрией» [management-telemetry](microservices%2Fmanagement-telemetry) **[swagger.yaml](microservices%2Fmanagement-telemetry%2Fswagger.yaml) [asyncapi.yaml](microservices%2Fmanagement-telemetry%2Fasyncapi.yaml)**  
- Микросервис «Управление устройствами» [management-device](microservices%2Fmanagement-device) **[swagger.yaml](microservices%2Fmanagement-device%2Fswagger.yaml)  [asyncapi.yaml](microservices%2Fmanagement-device%2Fasyncapi.yaml)**

### 4. Интеграция с монолитом

Укажите, какой способ взаимодействия микросервисов с монолитом вы выбрали. Поясните, почему остановились именно на нём.

### **5. Развёртывание в Minikube, либо Docker Compose**

Опишите полную инструкцию для развёртывания с нуля вашего решения, а так же тестовые запросы — Swagger.

Стартуем minikube 
```shell
minikube start
```

- Перейдите в директорию с Helm-чартом:
```shell
cd ./microservices-chart
```
- Разверните микросервисы
```shell
helm install  microservices ./
```
- Разверните микросервисы:
 
### Проверка состояния
```shell
 kubectl get all
```
и проверить, что все поды в статусе RUNNING 
- тестирование
получить ip minikube
```shell
minikube ip
```
в моем случае 192.168.49.2 
#### тестрование микросервисов
#### Управление телеметрией  
- Сохранение  
```shell
curl -X POST http://192.168.49.2:30081/api/telemetry/27b9213e-5922-44d3-9e0f-59dfe740b972/ \
-H "Content-Type: application/json" \
-d '{
  "transactionId": "123e4567-e89b-12d3-a456-426614174000",
  "data": {
    "metricType": "temperature",
    "value": 23.5
  }
```
получение телеметрии по id 
```shell

curl http://192.168.49.2:30081/api/telemetry/27b9213e-5922-44d3-9e0f-59dfe740b972
```
получении температуры 
```shell
curl http://192.168.49.2:30081/api/telemetry/27b9213e-5922-44d3-9e0f-59dfe740b972/temperature

```
#### Управление обрудованием
- Создание 
```shell
curl -X POST http://192.168.49.2:30080/api/devices \
     -H "Content-Type: application/json" \
     -d '{
    "typeId": "123e4567-e89b-12d3-a456-426614174000",
    "houseId": "223e4567-e89b-12d3-a456-426614174000", 
    "name": "Smart Thermostat",
    "serialNumber": "ST2024-001",
    "status": "ACTIVE",
    "transactionId": "323e4567-e89b-12d3-a456-426614174000"
}'
```
Получение информациии о оборудовании
```shell
curl http://192.168.49.2:30080/api/devices/d27e9d33-5a32-442c-9a22-d865ae669b54
```
Выключение включение
```shell
# Turn device on
curl -X PUT http://192.168.49.2:30080/api/devices/d27e9d33-5a32-442c-9a22-d865ae669b54/status \
     -H "Content-Type: application/json" \
     -d '{
    "status": "ON",
    "transactionId": "223e4567-e89b-12d3-a456-426614174000"
}'

# Turn device off
curl -X PUT http://192.168.49.2:30080/api/devices/d27e9d33-5a32-442c-9a22-d865ae669b54/status \
     -H "Content-Type: application/json" \
     -d '{
    "status": "OFF",
    "transactionId": "323e4567-e89b-12d3-a456-426614174000"
}'
```
## **Дополнительная часть**

В ходе работы над заданием вы можете по желанию выполнить ряд условий. Оставьте рядом с описанием условий смайлик, который соответствует статусу решения, и своё пояснение:

- ✅  Реализован паттерн Saga для управления распределенными транзакциями между микросервисами.
- ❌ Разделены операции чтения и записи данных в микросервисах с помощью паттерна CQRS.
- ✅ Применены дополнительные принципы 12-факторных приложений.
- ✅ Использован Kafka кластер для обеспечения отказоустойчивости и масштабируемости.

# ✅  Задание 3. Подготовка 3rd party сервисов для связи микросервисов

1. ✅  **Развёрнут и настроен кластер Kafka.**
Этот пункт задания выполнять необязательно. Это зависит от того, как вы реализовали своё решение. Оставьте рядом с пунктом тот смайлик, который отражает ваш выбор. Если используете кластер Kafka, добавьте сюда ссылку.
   Для тестирования в микросервисе телеметрии создан rest point
```shell

curl -X POST   http://<ip_minikube>:30081/api/sensor-data/send   -H "Content-Type: application/json"   -d '{
    "deviceId": "e9f8c3ad-44ea-4f9c-8306-56003491b0c3",
    "temperature": 22.5,
    "humidity": 45.3,
    "timestamp": "2024-12-18T10:15:30Z",
    "transactionId": "123e4567-e89b-12d3-a456-426614174000"
  }'

```
Он отправляет в топик "sensor_data" сообщение.
В результате в таблице должно появиться 2 записи. Одна о температуре, другая о влажности. 
Что бы проверить достаточно выполнить запрос:
```shell
curl http://<ip_minikube>:30081/api/telemetry/e9f8c3ad-44ea-4f9c-8306-56003491b0c3

```
- где <ip_minikube> ip адрес полученный через команду
```shell
 minikube ip
```
2. **Развёрнут и настроен API Gateway**
Поясните, какие технологии для API Gateway вы используете. Оставьте ссылку.
3. **Тестирование**
Поясните, какие команды нужно использовать для тестирования.

# Автоматизация поставки

# ✅ Задание 1. Контейнеризация микросервисов

1. **Созданы Helm-чарты** 
- [microservices-chart](microservices%2Fmicroservices-chart)
2. **Docker-образы собраны и загружены в хранилище артефактов**
Добавьте сюда ссылку на GitHub Container Registry.
 - [Образ management-telemetry](ghcr.io/vlfors/architecture-sprint-3/management-telemetry:latest)
 - [Образ management-device](ghcr.io/vlfors/architecture-sprint-3/management-device:latest)
3. **Запуск сервисов**
Напишите, какие команды нужно использовать для запуска сервисов с нуля.
4. **Тестирование работы сервисов**
Напишите, какие команды нужно использовать для тестирования.

# ✅ Задание 2. Настройка CI/CD-пайплайнов **c помощью GitHub Actions**

**Созданы CI/CD-пайплайны для каждого микросервиса**
   Опишите шаги пайплайна GitHub Actions в ci.yaml и добавьте сюда ссылку на этот файл.
Опишите шаги, которые нужно пройти для сборки, тестирования, загрузки образов в хранилище артефактов и обновления Helm релиза в Minikube.
   [docker-publish.yml](.github%2Fworkflows%2Fdocker-publish.yml)
1.       Запуск на ветке project_part_2:

Workflow срабатывает при пуше изменений в указанную ветку.
2. Настройка разрешений:

Предоставлены права на чтение содержимого репозитория и запись в пакеты (packages: write).
3. Клонирование репозитория:

С помощью actions/checkout@v3 код проекта скачивается для дальнейшей работы.
4. Установка JDK:

Устанавливается JDK версии 17 через actions/setup-java@v3.
5. Сборка JAR-файлов:

* Для каждого микросервиса выполняется mvn clean package в соответствующих директориях:
management-device
management-telemetry
Авторизация в GitHub Container Registry (GHCR):

Выполняется логин в GHCR с использованием токена GITHUB_TOKEN.
1. Сборка и пуш Docker-образов:

* Для каждого микросервиса:
Выполняется docker build для создания Docker-образа.
Образ пушится в GHCR под тегом latest.
* - [Образ management-telemetry](ghcr.io/vlfors/architecture-sprint-3/management-telemetry:latest)
- [Образ management-device](ghcr.io/vlfors/architecture-sprint-3/management-device:latest)
2. **Настроены триггеры для запуска пайплайнов**

    Пайплайны настроены на запуск при каждом пуше кода в репозиторий.

3. **Проверена работа пайплайнов**

    Пайплайн автоматически запускается и успешно выполняет все этапы: сборка, тестирование, развертывание. Добавьте сюда ссылку, по которой можно посмотреть выполнение пайплайнов.
